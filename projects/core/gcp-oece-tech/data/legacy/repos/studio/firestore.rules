/**
 * @fileoverview Firestore Security Rules for Digital Nomad Compass.
 *
 * Core Philosophy:
 * This ruleset enforces a tiered access model based on user roles and invitation codes.
 * - Guests (unauthenticated) have very limited read access.
 * - Free users (authenticated) have broader read access.
 * - PRO users (paid) have access to exclusive content.
 * - Admins have content management privileges.
 * Registration is controlled via an invitation code system.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, roles, and invite counts.
 * - /articles/{articleId}: Stores articles. Publicly readable, with write access for admins. PRO articles are restricted.
 * - /invites/{inviteCode}: Stores invitation codes.
 * - /roles_admin/{userId}: Legacy, admin check is now role-based on the user document.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided user ID.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the user has a specific role.
     */
    function hasRole(role) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == role;
    }

    /**
     * @description Checks if the user is an admin.
     */
    function isAdmin() {
      return hasRole('admin');
    }

     /**
     * @description Checks if the user is a PRO member or an admin.
     */
    function isProOrAdmin() {
        let userRole = get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
        return userRole == 'pro' || userRole == 'admin';
    }

    /**
     * @description Checks if an invitation code is valid and unused.
     */
    function isValidInvite(inviteCode) {
        let codeDoc = get(/databases/$(database)/documents/invites/$(inviteCode));
        return codeDoc.exists() && codeDoc.data.isUsed == false;
    }

    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) New user creation is complex: requires a valid invite code, and the new user doc must have correct initial values.
     * @allow (get, update) Authenticated user accesses their own profile.
     * @deny (list, delete) Listing or deleting users is not permitted.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;

      // Allow user creation ONLY if they provide a valid, unused invite code.
      // The request must also set the role to 'free' and invites to 2.
      allow create: if isOwner(userId) &&
                       isValidInvite(request.resource.data.inviteCode) &&
                       request.resource.data.role == 'free' &&
                       request.resource.data.invites == 2 &&
                       request.resource.data.email == request.auth.token.email;

      allow update: if isOwner(userId);
      allow delete: if false; // Users cannot delete their own accounts through rules.
    }

    /**
     * @description Rules for invitation codes.
     * @path /invites/{inviteCode}
     * @allow (get) Any signed-in user can check if a code exists.
     * @allow (create) A signed-in user can create a new invite code if they have invites remaining.
     * @allow (update) Only the system (via create user transaction) can mark a code as used.
     */
    match /invites/{inviteCode} {
        allow get: if isSignedIn();

        // Allow creating a code if the creator is the signed-in user and has invites.
        // This should be done in a transaction to decrement the user's invite count.
        allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;

        // Allow updating a code (to mark as used) only during the user creation process.
        // This is implicitly handled by the transaction that creates the user.
        // A direct update to 'isUsed' is only allowed if it's part of that transaction.
        allow update: if getAfter(/databases/$(database)/documents/invites/$(inviteCode)).data.isUsed == true &&
                         resource.data.isUsed == false;

        allow delete: if false;
    }

    /**
     * @description Rules for articles.
     * @path /articles/{articleId}
     * @allow (get, list) Anyone can read non-PRO articles. PRO articles require PRO or Admin role.
     * @allow (create, update, delete) Only admins can write articles.
     */
    match /articles/{articleId} {
      allow get: if resource.data.isPro == false || (isSignedIn() && isProOrAdmin());
      allow list: if true; // Lists are filtered on the client, but rules can't filter lists.

      allow create, update, delete: if isAdmin();
    }
  }
}
